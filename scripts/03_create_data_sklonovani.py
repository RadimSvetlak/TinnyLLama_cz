# ------------------------------------------------------------
# N√°zev: Gener√°tor tr√©ninkov√Ωch dat pro sklo≈àov√°n√≠ ƒçesk√Ωch podstatn√Ωch jmen
# Popis:
#   Tento skript vytv√°≈ô√≠ tr√©ninkov√© datasety pro model (nap≈ô. Gemma/LLaMA)
#   urƒçen√© ke zpracov√°n√≠ a pochopen√≠ ƒçesk√©ho sklo≈àov√°n√≠.
#
#   Obsahuje:
#     - Funkci pro vyps√°n√≠ v≈°ech vzor≈Ø a jejich tvar≈Ø podle p√°d≈Ø.
#     - Rodovƒõ specifick√© instrukce a p≈ô√≠klady (rod_templates).
#     - Funkce create_gemini_prompts a create_gemini_prompts2, kter√© pro zadan√°
#       slova a vzory sestav√≠ prompty s √∫kolem k vygenerov√°n√≠ spr√°vn√Ωch p√°dov√Ωch
#       tvar≈Ø.
#     - Funkci process_prompts_with_gemma, kter√° ode≈°le tyto prompty do modelu,
#       zpracuje odpovƒõƒè a ulo≈æ√≠ ji v nƒõkolika variant√°ch (p≈ô√≠m√° ot√°zka,
#       p√°dov√° ot√°zka, dopl≈àovac√≠ vƒõta) do JSONL souboru.
#     - Funkci create_data, kter√° generuje sadu obecn√Ωch tr√©ninkov√Ωch p≈ô√≠klad≈Ø
#       na z√°kladƒõ dostupn√Ωch vzor≈Ø, slov a jejich p√°dov√Ωch tvar≈Ø.
#
# Vstupy:
#   - Slovn√≠ky declension_patterns a vzorova_slova s definicemi vzor≈Ø a
#     vzorov√Ωch slov.
#   - Lok√°ln√≠ instance modelu (llm) pro generov√°n√≠ tvar≈Ø.
#
# V√Ωstupy:
#   - Soubor vystup_trenink.jsonl obsahuj√≠c√≠ prompty a spr√°vn√© odpovƒõdi
#     pro tr√©nink modelu na sklo≈àov√°n√≠.
#   - Soubor train_prompts.jsonl s obecn√Ωmi tr√©ninkov√Ωmi p√°ry prompt‚Äìcompletion.
#
# Z√°vislosti:
#   - Python 3.8+
#   - llama-cpp-python
#   - Strukturovan√° vstupn√≠ data ve slovn√≠c√≠ch s p√°dov√Ωmi vzory a slovy.
#
# ------------------------------------------------------------



import google.generativeai as genai
import time
import re
import json
# Slovn√≠k sklo≈àovac√≠ch vzor≈Ø s p≈ô√≠klady tvar≈Ø v jednotliv√Ωch p√°dech

from llama_cpp import Llama

# üß† Inicializace modelu Gemma
llm = Llama(
    #model_path="D:\\AI\\gemma_test\\google_gemma-3-12b-it-IQ2_M.gguf",  # nahraƒè cestou k modelu
    #model_path="D:\\AI\\gemma_test\\google_gemma-3-4b-it-qat-Q6_K.gguf",
    model_path="D:\\AI\\gemma_test\\google_gemma-3-12b-it-qat-Q2_K.gguf",
    n_ctx=2048,
    n_threads=12,
    n_gpu_layers=-1,
    n_batch=512,
    verbose=False
)



declension_patterns = {
    "≈æensk√Ω": {
        "≈æena": ["≈æena", "≈æeny", "≈æenƒõ", "≈æenu", "≈æeno", "≈æenƒõ", "≈æenou"],
        "r≈Ø≈æe": ["r≈Ø≈æe", "r≈Ø≈æe", "r≈Ø≈æi", "r≈Ø≈æi", "r≈Ø≈æe", "r≈Ø≈æi", "r≈Ø≈æ√≠"],
        "p√≠se≈à": ["p√≠se≈à", "p√≠snƒõ", "p√≠sni", "p√≠se≈à", "p√≠sni", "p√≠sni", "p√≠sn√≠"],
        "kost": ["kost", "kosti", "kosti", "kost", "kosti", "kosti", "kost√≠"]
    },
    "st≈ôedn√≠": {
        "mƒõsto": ["mƒõsto", "mƒõsta", "mƒõstu", "mƒõsto", "mƒõsto", "mƒõstƒõ", "mƒõstem"],
        "mo≈ôe": ["mo≈ôe", "mo≈ôe", "mo≈ôi", "mo≈ôe", "mo≈ôe", "mo≈ôi", "mo≈ôem"],
        "staven√≠": ["staven√≠", "staven√≠", "staven√≠", "staven√≠", "staven√≠", "staven√≠", "staven√≠m"],
        "d√≠tƒõ": ["d√≠tƒõ", "d√≠tƒõte", "d√≠tƒõti", "d√≠tƒõ", "d√≠tƒõ", "d√≠tƒõti", "d√≠tƒõtem"]
    },
    "mu≈æsk√Ω_≈æivotn√Ω": {
        "mu≈æ": ["mu≈æ", "mu≈æe", "mu≈æi", "mu≈æe", "mu≈æi", "mu≈æi", "mu≈æem"],
        "p√°n": ["p√°n", "p√°na", "p√°novi", "p√°na", "p√°ne", "p√°novi", "p√°nem"],
        "soudce": ["soudce", "soudce", "soudci", "soudce", "soudce", "soudci", "soudcem"],
        "uƒçitel": ["uƒçitel", "uƒçitele", "uƒçiteli", "uƒçitele", "uƒçiteli", "uƒçiteli", "uƒçitelem"]
    },
    "mu≈æsk√Ω_ne≈æivotn√Ω": {
        "hrad": ["hrad", "hradu", "hradu", "hrad", "hrade", "hradƒõ", "hradem"],
        "stroj": ["stroj", "stroje", "stroji", "stroj", "stroji", "stroji", "strojem"],
    }
}


vzorova_slova = {
    "≈æensk√Ω": {
        "≈æena": ["pƒõna", "noha", "matka", "ruka", "dcera", "chudoba", "sestra", "tov√°rna", "kniha"],
        "r≈Ø≈æe": ["k≈Ø≈æe", "uƒçebnice", "pr√°ce", "ulice", "nemocnice", "du≈°e", "ulice", "nadƒõje"],
        "p√≠se≈à": ["pl√≠se≈à", "zbra≈à", "my≈°", "vƒõ≈æ", "zeƒè"],
        "kost": ["radost", "startost", "noc", "moc", "smrt", "ƒç√°st", "vlhkost"]
    },
    "st≈ôedn√≠": {
        "mƒõsto": ["tƒõsto", "auto", "kolo", "okno", "jablko", "divadlo", "pouzdro", "raz√≠tko"],
        "mo≈ôe": ["pole", "srdce", "nebe", "slunce", "vejce"],
        "staven√≠": ["nastaven√≠", "n√°dra≈æ√≠", "na≈ô√≠zen√≠", "≈ô√≠zen√≠", "podez≈ôen√≠"],
        "d√≠tƒõ": ["≈°tƒõnƒõ", "kotƒõ", "≈°tƒõnƒõ", "ml√°dƒõ", "zv√≠≈ôe"]
    },
    "mu≈æsk√Ω_≈æivotn√Ω": {
        "mu≈æ": ["ml≈æ", "n≈Ø≈æ", "hr√°ƒç", "hospod√°≈ô", "p≈ô√≠tel"],
        "p√°n": ["km√°n", "voj√°k", "dƒõdeƒçek", "soused", "student"],
        "soudce": [ "poslanec", "v≈Ødce", "l√©ka≈ô", "ochr√°nce"],
        "p≈ôedseda": ["hrdina", "kolega", "turista", "spr√°vce", "kupec"]
    },
    "mu≈æsk√Ω_ne≈æivotn√Ω": {
        "hrad": ["hrad", "zub", "se≈°it", "p≈ô√≠stav", "les"],
        "stroj": ["stroj", "pokoj", "vlak", "st≈Øl", "batoh"],
    }
}


# V√Ωpis v≈°ech vzor≈Ø a tvar≈Ø
def print_declension_patterns():
    for gender, patterns in declension_patterns.items():
        print(f"\nRod: {gender}")
        for pattern, forms in patterns.items():
            print(f"  Vzor: {pattern}")
            print(f"    P√°dy: {', '.join(forms)}")



# rodovƒõ specifick√° pravidla a p≈ô√≠klady
rod_templates = {
    "≈æensk√Ω": """\
- P≈ôechylov√°n√≠: dcera -> dce≈ôi, h≈Øl -> holi
- Jemn√© zmƒõny samohl√°sek: ƒõ po d, t, n
- Zmƒõna samohl√°sky: ƒõ po p, b, v, ale pozor na v√Ωjimky jako nap≈ô. 'matka', kde je spr√°vn√Ω tvar 'matce' a ne 'matƒõ'.
- Mƒõkk√© souhl√°sky: k -> c (matka -> matce), h -> z (noha -> noze)
- Vynech√°n√≠ e po mƒõkk√© souhl√°sce: p√≠se≈à -> p√≠sni
V√Ωjimky: Je d≈Øle≈æit√©, aby model spr√°vnƒõ pochopil kl√≠ƒçov√© v√Ωjimky, jako jsou 'matka' -> 'matce' a 'pƒõna' -> 'pƒõnƒõ'. 
Tyto v√Ωjimky se objevuj√≠ i v jin√Ωch slovech, kde se sklo≈àov√°n√≠ m≈Ø≈æe li≈°it od bƒõ≈æn√©ho vzoru.
P≈ô√≠klady: 
tvary slova praha = "praha, prahy, praze, prahu, praho, praze, prahou", 
tvary slova matka = "matka, matky, matce, matku, matko, matce, matkou"\
tvary slova chudoba = "chudoba, chudoby, chudobƒõ, chudobu, chudobo, chudobƒõ, chudobou"\
""",

    "mu≈æsk√Ω_≈æivotn√Ω": """\
- 'y' po tvrd√Ωch (h, ch, k, r, d, t, n) 
- 'i' po mƒõkk√Ωch (≈æ, ≈°, ƒç, ≈ô, c, j)
- P≈ôechylov√°n√≠ kmene: pes / psa  
- vynech√°n√≠ e po mƒõkk√© souhl√°sce na konci: dƒõdeƒçek / dƒõdeƒçka
P≈ô√≠klad: 
- tvary slova pes: "pes, psa, psem, psa..."\
- tvary slova n≈Ø≈æ: - "n≈Ø≈æ, no≈æe, no≈æi, n≈Ø≈æ, no≈æi, no≈æi, no≈æem"
""",

    "mu≈æsk√Ω_ne≈æivotn√Ω": """\
- Zmƒõna ≈Ø -> o v lok√°lu/instrument√°lu (st≈Øl -> stolu)
- i/y dle tvrdosti souhl√°sek
P≈ô√≠klady: 
- tvary slova st≈Øl - "st≈Øl, stolu, stolu, st≈Øl, stole, stolu, stolem"
    \
""",

    "st≈ôedn√≠": """\
Specifika pro rod st≈ôedn√≠:
- Vokativ ƒçasto identick√Ω s nominativem
P≈ô√≠klady: 
tvary slova tƒõsto: "tƒõsto, tƒõsta, tƒõstu, tƒõsto, tƒõsto, tƒõstƒõ, tƒõstem"\
"""
}

def create_gemini_prompts():
    gemini_prompts = []
    cases = [
        "nominativ", "genitiv", "dativ",
        "akuzativ", "vokativ", "lok√°l", "instrument√°l"
    ]

    for rod, vzory in vzorova_slova.items():
        for vzor, words in vzory.items():
            if vzor not in declension_patterns.get(rod, {}):
                continue

            # p≈ôiprav√≠me text paradigmatu 1.‚Äì7. p√°du
            pattern_forms = declension_patterns[rod][vzor]
            pattern_lines = [
                f"{idx+1}. p√°d ({cases[idx]}): {form}"
                for idx, form in enumerate(pattern_forms)
            ]
            pattern_text = "\n".join(pattern_lines)

            for word in words:
                # base prompt s √∫kolem a uk√°zkou vzoru
                base_prompt = (
                    f"√ökolem je vysklo≈àovat slovo \"{word}\" podle vzoru \"{vzor}\".\n\n"
                    f"Sklo≈àov√°n√≠ vzoru \"{vzor}\" je n√°sleduj√≠c√≠:\n"
                    f"{pattern_text}\n\n"
                    f"P≈ôi sklo≈àov√°n√≠ pamatujte na mo≈æn√© v√Ωjimky:\n"
                )

                # p≈ôid√°me rodovƒõ specifick√© instrukce
                rod_instr = rod_templates.get(rod, "")

                # spoj√≠me v≈°e dohromady
                prompt = (
                    base_prompt
                    + rod_instr
                    + "\n\n"
                    + f"Vysklo≈àujte \"{word}\", ka≈æd√Ω tvar na nov√Ω ≈ô√°dek."
                    + "\nPamatujte, nepou≈æ√≠vejte mno≈æn√© ƒç√≠slo ani zdrobnƒõliny. "
                    + "\n Odpov√≠dej jedn√≠m slovem, kter√© je ve spr√°vn√©m tvaru"
                )

                gemini_prompts.append({
                    "prompt": prompt.strip(),
                    "completion": "",
                    "word": word,
                    "muster": vzor
                })

    process_prompts_with_gemma(gemini_prompts)
    return gemini_prompts
    
    
    

# üß† Vytvo≈ô tr√©ninkov√© prompty
def create_gemini_prompts2():
    gemini_prompts = []
    cases = ["nominativ", "genitiv", "dativ", "akuzativ", "vokativ", "lok√°l", "instrument√°l"]

    for rod, vzory in vzorova_slova.items():
        for vzor, words in vzory.items():
            if vzor not in declension_patterns.get(rod, {}):
                continue

            pattern_forms = declension_patterns[rod][vzor]
            pattern_lines = [
                f"{idx+1}. p√°d ({cases[idx]}): {form}"
                for idx, form in enumerate(pattern_forms)
            ]
            pattern_text = "\n".join(pattern_lines)

            for word in words:
                prompt = (
                    f"√ökolem je vysklo≈àovat slovo \"{word}\" podle vzoru \"{vzor}\".\n\n"
                    f"Sklo≈àov√°n√≠ vzoru \"{vzor}\" je n√°sleduj√≠c√≠:\n"
                    f"{pattern_text}\n\n"
                    f"P≈ôi sklo≈àov√°n√≠ pamatujte na mo≈æn√© v√Ωjimky:\n"
                    f"- P≈ôechylov√°n√≠: nap≈ô. dcera/dce≈ôi, h≈Øl/holi.\n"
                    f"- Y po tvrd√Ωch souhl√°sk√°ch : h ch k r d t n \n"
                    f"- ƒö po po mƒõkk√Ωch souhl√°sk√°ch : d t n \n"
                    f"- zmƒõnu p√≠smene: h -> z (praha / praze),  ≈Ø -> o (st≈Øl / stolu)," 
                    f"- Zmƒõna zakonƒçen√≠: nap≈ô. zeƒè/zdi.\n"
                    f"- Specifick√© tvary vokativu (nap≈ô. osloven√≠).\n\n"
                    f"Vysklo≈àujte \"{word}\", ka≈æd√Ω tvar na nov√Ω ≈ô√°dek.\n"
                    f"Pamatujte, nepou≈æ√≠vejte mno≈æn√© ƒç√≠slo ani zdrobnƒõliny.\n"
                )
                gemini_prompts.append({
                    "prompt": prompt,
                    "completion": "",
                    "word": word,
                    "muster": vzor
                })

    process_prompts_with_gemma(gemini_prompts)
    return gemini_prompts


import random

def process_prompts_with_gemma(prompts):
    output_file = "vystup_trenink.jsonl"
    total = len(prompts)

    with open(output_file, "w", encoding="utf-8") as f:
        pass;

    for idx, entry in enumerate(prompts, start=1):
        prompt_text = entry["prompt"]
        word = entry.get("word", "???")
        vzor = entry.get("muster", "???")

        print(f"\nüü° Pos√≠l√°m prompt {idx} / {total}: {word} ({vzor})")

        try:
            # üîÅ Vytvo≈ô prompt pro Gemmu
            full_prompt = (
                "<start_of_turn>user\n"
                "Jsi u≈æiteƒçn√Ω chatbot, kter√Ω rozum√≠ ƒçesky. "
                "Kdy≈æ tƒõ po≈æ√°d√°m o sklo≈àov√°n√≠ slova, odpov√≠≈° sedmi tvary v po≈ôad√≠ p√°d≈Ø.\n\n"
                f"{prompt_text}\n"
                "<end_of_turn>\n<start_of_turn>model\n"
            )

            # üîç Zavolej model
            response = llm(full_prompt, max_tokens=512)
            raw_output = response["choices"][0]["text"].strip()
            print(f"üü¢ prompt_text:\n{prompt_text}")
            print(f"üü¢ Odpovƒõƒè:\n{raw_output}")

            # üßπ Zpracuj v√Ωstup ‚Äì fallback logika
            lines = [line.strip() for line in raw_output.split("\n") if line.strip()]
            forms = []

            for line in lines:
                match = re.search(r"^\d\.?\s*p√°d:?\s*(.+)", line, re.IGNORECASE) or \
                        re.search(r"^\d\.?\s*:? (.+)", line) or \
                        re.match(r"^[A-Za-z√Å-≈Ω√°-≈æ\-]+$", line)
                if match:
                    cleaned = re.sub(r"^\(?.*?\):\s*", "", line)
                    forms.append(cleaned.strip())



            if len(forms) < 3:
                print(f"‚ö†Ô∏è V√Ωstup je p≈ô√≠li≈° kr√°tk√Ω ({len(forms)} tvar≈Ø) ‚Äì p≈ôeskoƒçeno")
                continue


            # P√°dov√© ot√°zky a n√°zvy p√°d≈Ø
            padove_otazky = [
                ("Nominativ", "Kdo? Co?"),
                ("Genitiv", "Koho? ƒåeho?"),
                ("Dativ", "Komu? ƒåemu?"),
                ("Akuzativ", "Koho? Co?"),
                ("Vokativ", "Osloven√≠"),
                ("Lok√°l", "O kom? O ƒçem?"),
                ("Instrument√°l", "S k√Ωm? S ƒç√≠m?")
            ]
   

            # üíæ Ulo≈æ do souboru
            sentence_starters = {
                "1. p√°d": ["Toto je ", "Zde stoj√≠ ", "Tohle je ", "Za dve≈ômi je ", "Hlavn√≠ hrdina je "],
                "2. p√°d": ["Nep≈Øjde to bez ", "Vid√≠m to uprost≈ôed ", "Bylo to bez ", "Boj√≠m se ", "Zbavil jsem se "],
                "3. p√°d": ["Ta to dƒõkuji ", "R√°d pom√°h√°m ", "Vƒõ≈ô√≠m ", "Svƒõ≈ôil jsem se ", "Odpov√≠d√°m "],
                "4. p√°d": ["Zde vid√≠m ", "K tomu pot≈ôebuji ", "St√°le hled√°m ", "M√°m r√°d ", "ƒåek√°m na "],
                "5. p√°d": ["Vol√°m v√°s, ", "Vid√≠m v√°s, ", "Sly≈°√≠m v√°s, ", "Kde jste, ", "V√°≈æen√Ω "],
                "6. p√°d": ["Mluvili jsme o ", "P√≠≈°u o ", "Zm√≠nil se o ", "P≈ôem√Ω≈°l√≠m o ", "ƒåtu o "],
                "7. p√°d": ["Jdu s ", "Pracuji s ", "Setkal jsem se s ", "Malujeme s ", "Mluv√≠m s "]
            }

            # üíæ Ulo≈æ do souboru
            with open(output_file, "a", encoding="utf-8") as f:
                # jednotliv√© p√°dy
                for i, form in enumerate(forms[:7]):
                    
                    # 1) -----  konkr√©tn√≠ tvar  ----- 
                    pair = {
                        "prompt": f"napi≈° slovo '{word}' v {i+1}. p√°dƒõ:",
                        "completion": form,
                    }
                    f.write(json.dumps(pair, ensure_ascii=False) + "\n")

                    pair = {
                        "prompt": f"vysklo≈àuj slovo {word} v {i+1}. p√°dƒõ",
                        "completion": form,
                    }
                    f.write(json.dumps(pair, ensure_ascii=False) + "\n")

                    # 2) p√°dov√° ot√°zka
                    nazev_padu, otazka = padove_otazky[i]
                    pad_question = {
                        "prompt": f"Na ot√°zku '{otazka}' odpov√≠d√° u slova '{word}' tvar:",
                        "completion": f"{form}"
                    }
                    f.write(json.dumps(pad_question, ensure_ascii=False) + "\n")

                    # 3) dopl≈àovac√≠ √∫loha s n√°hodn√Ωm zaƒç√°tkem
                    case_key = f"{i+1}. p√°d"
                    starter = random.choice(sentence_starters[case_key])
                    fill_prompt = {
                        "prompt": f"Dopl≈à spr√°vn√Ω tvar: {starter} ({word} v p√°dƒõ {nazev_padu})",
                        "completion": form
                    }
                    f.write(json.dumps(fill_prompt, ensure_ascii=False) + "\n")

                # obecn√Ω z√°pis v≈°ech tvar≈Ø
                general = {
                    "prompt": f"jak sklo≈àovat slovo {word} podle vzoru {vzor}",
                    "completion": "\n".join(forms[:7])
                }
                f.write(json.dumps(general, ensure_ascii=False) + "\n")


     

            time.sleep(2)

        except Exception as e:
            print(f"‚ùå Chyba p≈ôi vol√°n√≠ Gemmy: {e}")
            time.sleep(5)
            continue

    print(f"\n‚úÖ Hotovo: v√Ωstup ulo≈æen do souboru {output_file}")






def create_data():    

    # 1. Mapov√°n√≠ rod≈Ø pro vstupy
    gender_labels = {
        "≈æensk√Ω": "≈æensk√©m roce",
        "st≈ôedn√≠": "st≈ôedn√≠m rodƒõ",
        "mu≈æsk√Ω_≈æivotn√Ω": "mu≈æsk√©m ≈æivotn√©m rodƒõ",
        "mu≈æsk√Ω_ne≈æivotn√Ω": "mu≈æsk√©m ne≈æivotn√©m rodƒõ"
    }

    jsonl_lines = []

    # 1) Seznam vzor≈Ø podle rodu
    for gender, patterns in declension_patterns.items():
        label = gender_labels[gender]
        vzory = ", ".join(patterns.keys())
        prompt = f"Jak√© jsou vzory podstatn√Ωch jmen v {label}?"
        jsonl_lines.append({"prompt": prompt, "completion": vzory})

    # 2) Vzorov√° slova
    for gender, groups in vzorova_slova.items():
        for vzor, words in groups.items():
            prompt = f"Uveƒè 5 podstatn√Ωch jmen podle vzoru '{vzor}'."
            completion = ", ".join(words)
            jsonl_lines.append({"prompt": prompt, "completion": completion})

    # 3) V≈°echny tvary slova
    for gender, patterns in declension_patterns.items():
        for slovo, tvary in patterns.items():
            prompt = f"Jak√© jsou tvary slova '{slovo}'?"
            completion = ", ".join(tvary)
            jsonl_lines.append({"prompt": prompt, "completion": completion})

    # 4) Konkr√©tn√≠ p√°d
    for patterns in declension_patterns.values():
        for slovo, tvary in patterns.items():
            for idx, tvar in enumerate(tvary, start=1):
                prompt = f"{idx}. p√°d slova '{slovo}'"
                completion = tvar
                jsonl_lines.append({"prompt": prompt, "completion": completion})

    # Ulo≈æen√≠ do JSONL
    with open("train_prompts.jsonl", "w", encoding="utf-8") as f:
        for entry in jsonl_lines:
            f.write(json.dumps(entry, ensure_ascii=False) + "\n")    



# Spu≈°tƒõn√≠ v√Ωpisu
if __name__ == "__main__":
    create_data()
    create_gemini_prompts()
    print_declension_patterns()